// Generated by CoffeeScript 1.9.2
(function() {
  var Observer, Publisher, Signal, _, _module,
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _module = typeof window !== "undefined" && window !== null ? window : module;

  _module[_module.exports != null ? "exports" : "Chocodash"] = _ = {};

  _.type = function(o) {
    return Object.prototype.toString.apply(o);
  };

  _.Type = {
    Object: '[object Object]',
    Array: '[object Array]',
    Boolean: '[object Boolean]',
    Number: '[object Number]',
    Date: '[object Date]',
    Function: '[object Function]',
    Math: '[object Math]',
    String: '[object String]',
    Undefined: '[object Undefined]',
    Null: '[object Null]'
  };

  _.isObject = function(o) {
    if (o == null) {
      return false;
    }
    switch (typeof o) {
      case 'object':
      case 'function':
        return true;
      default:
        return false;
    }
  };

  _.isBasicObject = function(o) {
    if (o == null) {
      return false;
    }
    return o.constructor === {}.constructor;
  };

  _.prototype = function(options, more) {
    var constructor, ctor, fn, k, name, prototype, v, value;
    if (more != null) {
      if (options != null) {
        for (k in more) {
          v = more[k];
          options[k] = v;
        }
      } else {
        options = more;
      }
      more = null;
    }
    prototype = (function() {
      var flatten;
      flatten = function() {
        var args;
        args = [];
        if (arguments[0] != null) {
          Array.prototype.push.apply(args, arguments);
        }
        return args;
      };
      return {
        use: function() {
          var len, m, o, ref;
          ref = flatten.apply(null, arguments);
          for (m = 0, len = ref.length; m < len; m++) {
            o = ref[m];
            o.call(this.prototype);
          }
          return this;
        },
        adopt: function() {
          var len, m, o, ref, ref1;
          ref = flatten.apply(null, arguments);
          for (m = 0, len = ref.length; m < len; m++) {
            o = ref[m];
            for (k in o) {
              if (!hasProp.call(o, k)) continue;
              v = o[k];
              this[k] = v;
            }
            ref1 = o.prototype;
            for (k in ref1) {
              if (!hasProp.call(ref1, k)) continue;
              v = ref1[k];
              this.prototype[k] = v;
            }
          }
          return this;
        },
        inherit: function(parent) {
          var child, ctor;
          child = this;
          if (parent != null) {
            for (k in parent) {
              if (!hasProp.call(parent, k)) continue;
              v = parent[k];
              child[k] = v;
            }
            ctor = function() {
              this.constructor = child;
            };
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
          }
          return this;
        }
      };
    })();
    constructor = (options != null ? options.hasOwnProperty('constructor') : void 0) ? options.constructor : null;
    ctor = (function() {
      switch (false) {
        case !((constructor != null) && ((options != null ? options.inherit : void 0) != null)):
          return function() {
            Array.prototype.unshift.call(arguments, this);
            _["super"].apply(_, arguments);
            Array.prototype.shift.call(arguments);
            constructor.apply(this, arguments);
          };
        case constructor == null:
          return function() {
            constructor.apply(this, arguments);
          };
        case (options != null ? options.inherit : void 0) == null:
          return function() {
            Array.prototype.unshift.call(arguments, this);
            _["super"].apply(_, arguments);
          };
        default:
          return function() {};
      }
    })();
    if (options != null) {
      for (name in options) {
        value = options[name];
        if (name === 'adopt' || name === 'inherit' || name === 'use') {
          prototype[name].call(ctor, value);
        } else {
          if (name !== 'constructor') {
            ctor.prototype[name] = value;
          }
        }
      }
    }
    for (name in prototype) {
      if (!hasProp.call(prototype, name)) continue;
      fn = prototype[name];
      if (ctor[name] == null) {
        ctor[name] = fn;
      }
    }
    return ctor;
  };

  _["super"] = function() {
    var _func, _name, constructor, func, k, ref, self, super_func, v;
    super_func = null;
    func = arguments[0], self = arguments[1];
    if (typeof func !== 'function') {
      self = func;
      func = null;
    }
    _func = func != null ? func : arguments.callee.caller;
    _name = null;
    constructor = self.constructor;
    if (constructor === _func.caller) {
      super_func = constructor.__super__.constructor;
    } else {
      while (constructor && (super_func == null)) {
        ref = constructor.prototype;
        for (k in ref) {
          if (!hasProp.call(ref, k)) continue;
          v = ref[k];
          if (_func === v) {
            _name = k;
            break;
          }
        }
        if (_name != null) {
          super_func = constructor.__super__[_name];
        }
        if (super_func == null) {
          constructor = constructor.__super__ != null ? constructor.__super__.constructor : null;
        }
      }
    }
    if (super_func) {
      return super_func.apply(self, Array.prototype.slice.call(arguments, func != null ? 2 : 1));
    }
  };

  _.stringify = function() {
    var doit, newline, object, options, ref, tab;
    if (arguments.length === 0) {
      return void 0;
    }
    object = arguments[0];
    options = (ref = arguments[1]) != null ? ref : {};
    if (options.prettify === true) {
      tab = '    ';
      newline = '\n';
    } else {
      tab = newline = '';
    }
    doit = function(o, level, p) {
      var indent, k, ni, nit, result, type, v;
      result = [];
      if (level == null) {
        level = 0;
      }
      indent = ((function() {
        var m, ref1, results;
        results = [];
        for (m = 0, ref1 = level; 0 <= ref1 ? m < ref1 : m > ref1; 0 <= ref1 ? m++ : m--) {
          results.push(tab);
        }
        return results;
      })()).join('');
      ni = newline + indent;
      nit = ni + tab;
      type = Object.prototype.toString.apply(o);
      result.push((function() {
        switch (type) {
          case '[object Object]':
            return "{" + nit + (((function() {
              var ref1, results;
              results = [];
              for (k in o) {
                v = o[k];
                if (((options.filter == null) || (ref1 = v.constructor, indexOf.call(options.filter, ref1) >= 0)) && (options.own !== true || {}.hasOwnProperty.call(o, k))) {
                  results.push(k + ':' + doit(v, level + 1));
                }
              }
              return results;
            })()).join(',' + nit)) + ni + "}";
          case '[object Array]':
            return "function () {" + nit + "var a = []; var o = {" + nit + (((function() {
              var results;
              results = [];
              for (k in o) {
                if (!hasProp.call(o, k)) continue;
                v = o[k];
                results.push(k + ':' + doit(v, level + 1));
              }
              return results;
            })()).join(',' + nit)) + "};" + nit + "for (var k in o) {a[k] = o[k];} return a; }()";
          case '[object Boolean]':
            return o;
          case '[object Number]':
            return o;
          case '[object Date]':
            return "new Date(" + (o.valueOf()) + ")";
          case '[object Function]':
            return o.toString();
          case '[object Math]':
            return 'Math';
          case '[object String]':
            return "'" + (o.replace(/\'/g, '\\\'')) + "'";
          case '[object Undefined]':
            return 'void 0';
          case '[object Null]':
            return 'null';
          case '[object Buffer]':
          case '[object SlowBuffer]':
            if (o.length === 16) {
              return _.Uuid.unparse(o);
            } else {
              return o.toString();
            }
        }
      })());
      return result;
    };
    return doit(object).join(', ');
  };

  _.parse = function(str) {
    return (new Function("return " + str))();
  };

  _.param = function(parameters) {
    var parameter, serialize;
    if (_.type(parameters) === _.Type.String) {
      return encodeURIComponent(parameters);
    }
    serialize = [];
    for (parameter in parameters) {
      if (!hasProp.call(parameters, parameter)) continue;
      serialize.push((encodeURIComponent(parameter)) + "=" + (encodeURIComponent(parameters[parameter])));
    }
    return serialize.join('&');
  };

  _.serialize = _.flow = function(options, fn) {
    var async, defer, deferred, fn_self, local, next, ref, self, undefer;
    if (fn == null) {
      fn = options;
      options = {};
    }
    self = options.self, local = options.local, async = options.async;
    if (local == null) {
      local = {};
    }
    deferred = [];
    async = false;
    defer = function(fn) {
      if (arguments.length === 2) {
        fn = arguments[1];
      }
      return deferred.push(fn);
    };
    undefer = function() {
      var undefered;
      undefered = deferred.shift();
      if (deferred.length === 0 && async === false && (options != null ? options.async : void 0) !== false) {
        return function(next) {
          self = this;
          return setTimeout((function() {
            return undefered.call(self, next);
          }), 0);
        };
      } else {
        return undefered;
      }
    };
    next = function() {
      var result;
      if (deferred.length) {
        result = undefer().call(self, next);
        switch (result) {
          case next:
            return async = true;
        }
      }
    };
    next.later = next;
    next["with"] = function(result) {
      if (result !== next.later) {
        return next();
      } else {
        return next.later;
      }
    };
    fn_self = self;
    if (fn_self == null) {
      fn_self = fn;
    }
    fn.call(fn_self, defer, local);
    return (ref = undefer()) != null ? ref.call(self, next) : void 0;
  };

  _.parallelize = function(self, fn) {
    var count, dfn, end, join, len, m, on_join, push, pushed, results;
    if (typeof self === 'function') {
      fn = self;
      self = fn;
    }
    pushed = [];
    on_join = null;
    join = function(fn) {
      return on_join = fn;
    };
    count = 0;
    end = function() {
      count += -1;
      if (count === 0) {
        return on_join != null ? on_join.call(self) : void 0;
      }
    };
    push = function(fn) {
      return pushed.push(function() {
        return setTimeout((function() {
          fn.call(self);
          return end();
        }), 0);
      });
    };
    fn.call(self, push, join);
    count = pushed.length;
    results = [];
    for (m = 0, len = pushed.length; m < len; m++) {
      dfn = pushed[m];
      results.push(dfn.call(self));
    }
    return results;
  };

  _.throttle = function(options, func) {
    var accumulate, args, call, ctx, last, reset, rtn, timeoutID, wait;
    wait = options.wait, reset = options.reset, accumulate = options.accumulate;
    if (wait == null) {
      wait = 1000;
    }
    if (reset == null) {
      reset = false;
    }
    if (accumulate == null) {
      accumulate = false;
    }
    ctx = void 0;
    args = void 0;
    rtn = void 0;
    timeoutID = void 0;
    last = 0;
    call = function() {
      timeoutID = void 0;
      last = (new Date).getTime();
      rtn = func.apply(ctx, args);
      ctx = void 0;
      args = void 0;
    };
    return function() {
      var delta;
      ctx = this;
      if (!accumulate) {
        args = arguments;
      } else if (args == null) {
        args = [arguments];
      } else {
        args.push(arguments);
      }
      delta = (new Date).getTime() - last;
      if (reset) {
        if (timeoutID != null) {
          clearTimeout(timeoutID);
        }
        timeoutID = setTimeout(call, wait);
      } else if (timeoutID == null) {
        if (delta >= wait) {
          call();
        } else {
          timeoutID = setTimeout(call, wait - delta);
        }
      }
      return rtn;
    };
  };

  _.extend = function(object, values, overwrite) {
    var set;
    set = function(o, val) {
      var k, v;
      for (k in val) {
        if (!hasProp.call(val, k)) continue;
        v = val[k];
        if (o == null) {
          o = {};
        }
        if (_.type(o[k]) === _.Type.Object && _.type(v) === _.Type.Object) {
          set(o[k], v);
        } else {
          if (!(overwrite === false && (o[k] != null))) {
            o[k] = v;
          }
        }
      }
      return o;
    };
    return set(object, values);
  };

  _.clone = function() {
    var clone, copy, copyIsArray, i, length, name, options, src, target;
    target = arguments[0] || {};
    i = 1;
    length = arguments.length;
    if (typeof target !== "object" && !_.type(target) === _.Type.Function) {
      target = {};
    }
    while (i < length) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if (copy && (_.isBasicObject(copy) || (copyIsArray = _.type(copy) === _.Type.Array))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && _.type(src) === _.Type.Array ? src : [];
            } else {
              clone = src && _.isBasicObject(src) ? src : {};
            }
            target[name] = _.clone(clone, copy);
          } else if (copy !== void 0) {
            target[name] = copy;
          }
        }
      }
      i += 1;
    }
    return target;
  };

  _.defaults = function(object, defaults) {
    return _.extend(object, defaults, false);
  };

  _.Signal = Signal = _.prototype({
    adopt: {
      type: "SIGNAL",
      arrayMethods: ["pop", "push", "reverse", "shift", "sort", "splice", "unshift"],

      /* Events on evalutate
          value   REPLACE - ALL
          set     REPLACE - ONE - at KEY
          delete  REMOVE - ONE - at KEY
          pop     REMOVE - ONE - at LAST
          push    INSERT - ONE or MANY - at END 
          reverse SORT - ALL
          shift   REMOVE - ONE - at FIRST
          sort    SORT - ALL
          splice  REMOVE - ONE or MANY - at INDEX and INSERT - ONE or MANY - at INDEX
          unshift INSERT - ONE or MANY - at FIRST
       */
      Event: {
        Type: {
          Insert: 0,
          Replace: 1,
          Remove: 2,
          Sort: 3
        },
        What: {
          All: 0,
          One: 1,
          Many: 2
        },
        Where: {
          First: 0,
          Last: 1,
          End: 2,
          Index: 3
        }
      },
      EventDef: {
        value: {
          type: 'Replace',
          what: 'All'
        },
        set: {
          type: 'Replace',
          what: 'One',
          where: 'Index'
        },
        "delete": {
          type: 'Remove',
          what: 'One',
          where: 'Index'
        },
        pop: {
          type: 'Remove',
          what: 'One',
          where: 'Last'
        },
        push: {
          type: 'Insert',
          what: 'One',
          where: 'End'
        },
        reverse: {
          type: 'Sort',
          what: 'all'
        },
        shift: {
          type: 'Remove',
          what: 'One',
          where: 'First'
        },
        sort: {
          type: 'Sort',
          what: 'all'
        },
        splice: {
          type: 'Remove',
          what: 'One',
          where: 'Index'
        },
        unshift: {
          type: 'Insert',
          what: 'One',
          where: 'First'
        }
      },
      dependencyStack: [],
      transactions: {},
      Defer: _.prototype({
        constructor: function(signal1, observerList1) {
          this.signal = signal1;
          this.observerList = observerList1;
          return this.count = 0;
        },
        value: function(fn) {
          var len, m, observer, ref, results, stack;
          stack = Signal.dependencyStack;
          Signal.dependencyStack = [this.signal];
          this.signal._value = fn();
          this.signal._initialized = true;
          this.signal._idle = true;
          Signal.dependencyStack = stack;
          this.count += -1;
          this.signal.propagate(this, this.observerList);
          ref = this.signal.observers;
          results = [];
          for (m = 0, len = ref.length; m < len; m++) {
            observer = ref[m];
            results.push(observer.notify(true));
          }
          return results;
        },
        one: function() {
          return this.count += 1;
        },
        idle: function() {
          return this.count === 0;
        }
      })
    },
    constructor: function(definition, helpers) {
      var fn1, helper, name, ref;
      this.definition = definition;
      this.helpers = helpers;
      ref = this.helpers;
      fn1 = function(helper, name, self) {
        return self.helpers[name] = function() {
          return helper.apply(self, arguments);
        };
      };
      for (name in ref) {
        helper = ref[name];
        fn1(helper, name, this);
      }
      this._value = null;
      this._initialized = false;
      this._idle = true;
      this.dependencies = [];
      this.dependencyType = Signal.type;
      this.dependents = [];
      this.observers = [];
      this.dependentTargets = [];
      return this.evaluate(new Signal.Defer(this));
    },
    evaluate: function(defer, observerList) {
      var aa, deferred, dependency, dependentIndex, e, fn1, len, len1, len2, len3, len4, m, methodName, observer, q, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, result, type, u, w;
      this._value = this.definition;
      this._idle = true;
      this._error = null;
      ref = this.dependencies;
      for (m = 0, len = ref.length; m < len; m++) {
        dependency = ref[m];
        dependentIndex = dependency.dependents.indexOf(this);
        dependency.dependents.splice(dependentIndex, 1);
      }
      this.dependencies = [];
      switch (type = _.type(this.definition)) {
        case _.Type.Function:
          Signal.dependencyStack.push(this);
          try {
            deferred = (function(signal) {
              return function(fn) {
                var prev;
                prev = defer.signal;
                defer.signal = signal;
                defer.value.call(defer, fn);
                return defer.signal = prev;
              };
            })(this);
            try {
              result = this.definition(deferred);
            } catch (_error) {
              e = _error;
              result = void 0;
              this._error = e;
              if (this._catch != null) {
                this._catch(e);
                this._error = null;
              }
            }
            if (result === deferred) {
              this._idle = false;
              defer.one();
              ref1 = this.observers;
              for (q = 0, len1 = ref1.length; q < len1; q++) {
                observer = ref1[q];
                observer.notify(false);
              }
            } else {
              this._value = result;
              this._initialized = true;
              this._idle = true;
            }
          } finally {
            Signal.dependencyStack.pop();
          }
          break;
        case _.Type.Object:
        case _.Type.Array:
          if (this.set == null) {
            this.set = (ref2 = (ref3 = this.helpers) != null ? ref3.set : void 0) != null ? ref2 : (function(_this) {
              return function(key, value) {
                if (arguments.length === 1) {
                  _this.definition = key;
                } else {
                  _this.definition[key] = value;
                }
                return _this.value(_this.definition);
              };
            })(this);
            this["delete"] = (ref4 = (ref5 = this.helpers) != null ? ref5["delete"] : void 0) != null ? ref4 : (function(_this) {
              return function(key) {
                delete _this.definition[key];
                return _this.value(_this.definition);
              };
            })(this);
            if (type === _.Type.Array) {
              ref6 = Signal.arrayMethods;
              fn1 = (function(_this) {
                return function(methodName) {
                  var ref7, ref8;
                  return _this[methodName] = (ref7 = (ref8 = _this.helpers) != null ? ref8[methodName] : void 0) != null ? ref7 : function() {
                    var output;
                    output = _this.definition[methodName].apply(_this.definition, arguments);
                    _this.value(_this.definition);
                    return output;
                  };
                };
              })(this);
              for (u = 0, len2 = ref6.length; u < len2; u++) {
                methodName = ref6[u];
                fn1(methodName);
              }
            }
          }
          break;
        default:
          if (this.set != null) {
            delete this.set;
            delete this["delete"];
            ref7 = Signal.arrayMethods;
            for (w = 0, len3 = ref7.length; w < len3; w++) {
              methodName = ref7[w];
              delete this[methodName];
            }
          }
      }
      if (observerList != null) {
        ref8 = this.observers;
        for (aa = 0, len4 = ref8.length; aa < len4; aa++) {
          observer = ref8[aa];
          if ((observer != null) && (observerList.indexOf(observer)) < 0) {
            observerList.push(observer);
          }
        }
      }
      if (!((deferred != null) && result === deferred)) {
        return this.propagate(defer, observerList);
      }
    },
    "catch": function(report) {
      this._catch = report;
      if (this._error != null) {
        this._catch(this._error);
        return this._error = null;
      }
    },
    idle: function() {
      return this._idle;
    },
    propagate: function(defer, observerList) {
      var dependent, len, m, ref, results;
      this.dependentTargets = this.dependents.slice(0);
      ref = this.dependents.slice(0);
      results = [];
      for (m = 0, len = ref.length; m < len; m++) {
        dependent = ref[m];
        if ((dependent != null) && this.dependentTargets.indexOf(dependent) >= 0) {
          results.push(dependent.evaluate(defer, observerList));
        } else {
          results.push(void 0);
        }
      }
      return results;
    },
    value: function(newDefinition) {
      var defer, dependent, len, m, observer, observerList, ref, targetDependentIndex;
      if (newDefinition !== void 0) {
        this.definition = newDefinition;
        observerList = [];
        defer = new Signal.Defer(this, observerList);
        this.evaluate(defer, observerList);
        if (defer.idle()) {
          ref = observerList.slice(0);
          for (m = 0, len = ref.length; m < len; m++) {
            observer = ref[m];
            observer.trigger();
          }
        }
        return this._value;
      } else {
        dependent = Signal.dependencyStack[Signal.dependencyStack.length - 1];
        if ((dependent != null) && dependent.dependencyType === Signal.type) {
          if (this.dependents.indexOf(dependent) < 0) {
            this.dependents.push(dependent);
          }
          if (dependent.dependencies.indexOf(this) < 0) {
            dependent.dependencies.push(this);
          }
          targetDependentIndex = this.dependentTargets.indexOf(dependent);
          if (targetDependentIndex >= 0) {
            this.dependentTargets[targetDependentIndex] = null;
          }
        } else if ((dependent != null) && dependent.dependencyType === Observer.type) {
          if (this.observers.indexOf(dependent) < 0) {
            this.observers.push(dependent);
          }
          if (dependent.observees.indexOf(this) < 0) {
            dependent.observees.push(this);
          }
        }
        return this._value;
      }
    }
  });

  _.Observer = Observer = _.prototype({
    adopt: {
      type: "OBSERVER"
    },
    constructor: function(report) {
      this.observees = [];
      this.dependencyType = Observer.type;
      return this.observe(report);
    },
    observe: function(report) {
      var len, len1, m, observee, observerIndex, q, ref, ref1;
      this.report = report;
      this._ready = true;
      ref = this.observees;
      for (m = 0, len = ref.length; m < len; m++) {
        observee = ref[m];
        observerIndex = observee.observers.indexOf(this);
        observee.observers.splice(dependentIndex, 1);
      }
      this.observees = [];
      Signal.dependencyStack.push(this);
      try {
        if (this.report != null) {
          this.report();
        }
      } finally {
        Signal.dependencyStack.pop();
      }
      this._ready = true;
      ref1 = this.observees;
      for (q = 0, len1 = ref1.length; q < len1; q++) {
        observee = ref1[q];
        if (!observee.idle()) {
          this._ready = false;
          break;
        }
      }
      return null;
    },
    notify: function(status) {
      var len, m, observee, ref;
      if (status === true) {
        this._ready = true;
        ref = this.observees;
        for (m = 0, len = ref.length; m < len; m++) {
          observee = ref[m];
          if (!observee.idle()) {
            this._ready = false;
            break;
          }
        }
        if (this._ready) {
          return this.trigger();
        }
      } else {
        return this._ready = false;
      }
    },
    trigger: function() {
      Signal.dependencyStack.push(this);
      try {
        if (this.report != null) {
          return this.report();
        }
      } finally {
        Signal.dependencyStack.pop();
      }
    },
    ready: function() {
      return this._ready;
    }
  });

  _.Publisher = Publisher = _.prototype({
    constructor: function() {
      return this.subscribers = [];
    },
    notify: function(value) {
      var len, m, ref, report, results;
      ref = this.subscribers;
      results = [];
      for (m = 0, len = ref.length; m < len; m++) {
        report = ref[m];
        results.push(report(value));
      }
      return results;
    },
    subscribe: function(reporter) {
      return this.subscribers.push(reporter);
    }
  });

  _.Uuid = (function(_module) {
    var BufferClass, _byteToHex, _clockseq, _hexToByte, _lastMSecs, _lastNSecs, _nodeId, _previousRoot, _rb, _rnds, _rnds8, _rng, _seedBytes, crypto, define, i, module, parse, require, unparse, uuid, v1, v4, whatwgRNG;
    require = _module.require, crypto = _module.crypto, define = _module.define, module = _module.module;
    _rng = void 0;
    if (typeof require === "function") {
      try {
        _rb = require("crypto").randomBytes;
        _rng = _rb && function() {
          return _rb(16);
        };
      } catch (_error) {}
    }
    if (!_rng && crypto && crypto.getRandomValues) {
      _rnds8 = new Uint8Array(16);
      _rng = whatwgRNG = function() {
        crypto.getRandomValues(_rnds8);
        return _rnds8;
      };
    }
    if (!_rng) {
      _rnds = new Array(16);
      _rng = function() {
        var i, r;
        i = 0;
        r = void 0;
        while (i < 16) {
          if ((i & 0x03) === 0) {
            r = Math.random() * 0x100000000;
          }
          _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
          i++;
        }
        return _rnds;
      };
    }
    BufferClass = (typeof Buffer === "function" ? Buffer : Array);
    _byteToHex = [];
    _hexToByte = {};
    i = 0;
    while (i < 256) {
      _byteToHex[i] = (i + 0x100).toString(16).substr(1);
      _hexToByte[_byteToHex[i]] = i;
      i++;
    }
    parse = function(s, buf, offset) {
      var ii;
      i = (buf && offset) || 0;
      ii = 0;
      buf = buf || [];
      s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
        if (ii < 16) {
          return buf[i + ii++] = _hexToByte[oct];
        }
      });
      while (ii < 16) {
        buf[i + ii++] = 0;
      }
      return buf;
    };
    unparse = function(buf, offset) {
      var bth;
      i = offset || 0;
      bth = _byteToHex;
      return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];
    };
    _seedBytes = _rng();
    _nodeId = [_seedBytes[0] | 0x01, _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]];
    _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1 = function(options, buf, offset) {
      var b, clockseq, dt, msecs, n, node, nsecs, tl, tmh;
      i = buf && offset || 0;
      b = buf || [];
      options = options || {};
      clockseq = (options.clockseq != null ? options.clockseq : _clockseq);
      msecs = (options.msecs != null ? options.msecs : new Date().getTime());
      nsecs = (options.nsecs != null ? options.nsecs : _lastNSecs + 1);
      dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs) / 10000;
      if (dt < 0 && (options.clockseq == null)) {
        clockseq = clockseq + 1 & 0x3fff;
      }
      if ((dt < 0 || msecs > _lastMSecs) && (options.nsecs == null)) {
        nsecs = 0;
      }
      if (nsecs >= 10000) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 12219292800000;
      tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
      b[i++] = tl >>> 24 & 0xff;
      b[i++] = tl >>> 16 & 0xff;
      b[i++] = tl >>> 8 & 0xff;
      b[i++] = tl & 0xff;
      tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
      b[i++] = tmh >>> 8 & 0xff;
      b[i++] = tmh & 0xff;
      b[i++] = tmh >>> 24 & 0xf | 0x10;
      b[i++] = tmh >>> 16 & 0xff;
      b[i++] = clockseq >>> 8 | 0x80;
      b[i++] = clockseq & 0xff;
      node = options.node || _nodeId;
      n = 0;
      while (n < 6) {
        b[i + n] = node[n];
        n++;
      }
      if (buf) {
        return buf;
      } else {
        return unparse(b);
      }
    };
    v4 = function(options, buf, offset) {
      var ii, rnds;
      i = buf && offset || 0;
      if (typeof options === "string") {
        buf = (options === "binary" ? new BufferClass(16) : null);
        options = null;
      }
      options = options || {};
      rnds = options.random || (options.rng || _rng)();
      rnds[6] = (rnds[6] & 0x0f) | 0x40;
      rnds[8] = (rnds[8] & 0x3f) | 0x80;
      if (buf) {
        ii = 0;
        while (ii < 16) {
          buf[i + ii] = rnds[ii];
          ii++;
        }
      }
      return buf || unparse(rnds);
    };
    uuid = v4;
    uuid.v1 = v1;
    uuid.v4 = v4;
    uuid.parse = parse;
    uuid.unparse = unparse;
    uuid.BufferClass = BufferClass;
    if (typeof define === "function" && define.amd) {
      define(function() {
        return uuid;
      });
    } else if (typeof module !== "undefined" && module.exports) {
      module.exports = uuid;
    } else {
      _previousRoot = _module.Uuid;
      uuid.noConflict = function() {
        _module.Uuid = _previousRoot;
        return uuid;
      };
      _module.Uuid = uuid;
    }
    uuid.isUuid = function(value) {
      var parsed, unparsed;
      if ((value != null) && Object.prototype.toString.apply(value === '[object String]' && value.length === 36)) {
        parsed = parse(value);
        unparsed = unparse(parsed);
        return value === unparsed;
      } else if (typeof Buffer === 'function' && Buffer.isBuffer(value)) {
        return value.length === 16;
      } else {
        return false;
      }
    };
    uuid["interface"] = function() {
      return uuid();
    };
    return uuid;
  })(_module);


  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */


  /*  SHA-256 implementation in JavaScript                (c) Chris Veness 2002-2014 / MIT Licence */


  /*  - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html */


  /*        http://csrc.nist.gov/groups/ST/toolkit/examples.html */


  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  _.Sha256 = (function() {

    /* global define, escape, unescape */
    var Sha256;
    Sha256 = void 0;
    Sha256 = {};

    /**
     * Generates SHA-256 hash of string.
    #
     * @param   {string} msg - String to be hashed
     * @returns {string} Hash of msg as hex character string
     */
    Sha256.hash = function(msg) {
      var H, K, M, N, T1, T2, W, a, b, c, d, e, f, g, h, i, j, l, t;
      t = void 0;
      t = void 0;
      i = void 0;
      H = void 0;
      K = void 0;
      M = void 0;
      N = void 0;
      T1 = void 0;
      T2 = void 0;
      W = void 0;
      a = void 0;
      b = void 0;
      c = void 0;
      d = void 0;
      e = void 0;
      f = void 0;
      g = void 0;
      h = void 0;
      i = void 0;
      j = void 0;
      l = void 0;
      t = void 0;
      msg = msg.utf8Encode();
      K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];
      H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];
      msg += String.fromCharCode(0x80);
      l = msg.length / 4 + 2;
      N = Math.ceil(l / 16);
      M = new Array(N);
      i = 0;
      while (i < N) {
        M[i] = new Array(16);
        j = 0;
        while (j < 16) {
          M[i][j] = msg.charCodeAt(i * 64 + j * 4) << 24 | msg.charCodeAt(i * 64 + j * 4 + 1) << 16 | msg.charCodeAt(i * 64 + j * 4 + 2) << 8 | msg.charCodeAt(i * 64 + j * 4 + 3);
          j++;
        }
        i++;
      }
      M[N - 1][14] = (msg.length - 1) * 8 / Math.pow(2, 32);
      M[N - 1][14] = Math.floor(M[N - 1][14]);
      M[N - 1][15] = (msg.length - 1) * 8 & 0xffffffff;
      W = new Array(64);
      a = void 0;
      b = void 0;
      c = void 0;
      d = void 0;
      e = void 0;
      f = void 0;
      g = void 0;
      h = void 0;
      i = 0;
      while (i < N) {
        t = 0;
        while (t < 16) {
          W[t] = M[i][t];
          t++;
        }
        t = 16;
        while (t < 64) {
          W[t] = Sha256.σ1(W[t - 2]) + W[t - 7] + Sha256.σ0(W[t - 15]) + W[t - 16] & 0xffffffff;
          t++;
        }
        a = H[0];
        b = H[1];
        c = H[2];
        d = H[3];
        e = H[4];
        f = H[5];
        g = H[6];
        h = H[7];
        t = 0;
        while (t < 64) {
          T1 = h + Sha256.Σ1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];
          T2 = Sha256.Σ0(a) + Sha256.Maj(a, b, c);
          h = g;
          g = f;
          f = e;
          e = d + T1 & 0xffffffff;
          d = c;
          c = b;
          b = a;
          a = T1 + T2 & 0xffffffff;
          t++;
        }
        H[0] = H[0] + a & 0xffffffff;
        H[1] = H[1] + b & 0xffffffff;
        H[2] = H[2] + c & 0xffffffff;
        H[3] = H[3] + d & 0xffffffff;
        H[4] = H[4] + e & 0xffffffff;
        H[5] = H[5] + f & 0xffffffff;
        H[6] = H[6] + g & 0xffffffff;
        H[7] = H[7] + h & 0xffffffff;
        i++;
      }
      return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) + Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);
    };

    /**
     * Rotates right (circular right shift) value x by n positions [§3.2.4].
     * @private
     */
    Sha256.ROTR = function(n, x) {
      return x >>> n | x << 32 - n;
    };

    /**
     * Logical functions [§4.1.2].
     * @private
     */
    Sha256.Σ0 = function(x) {
      return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x);
    };
    Sha256.Σ1 = function(x) {
      return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x);
    };
    Sha256.σ0 = function(x) {
      return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ x >>> 3;
    };
    Sha256.σ1 = function(x) {
      return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ x >>> 10;
    };
    Sha256.Ch = function(x, y, z) {
      return x & y ^ ~x & z;
    };
    Sha256.Maj = function(x, y, z) {
      return x & y ^ x & z ^ y & z;
    };

    /**
     * Hexadecimal representation of a number.
     * @private
     */
    Sha256.toHexStr = function(n) {
      var i, s, v;
      i = void 0;
      s = void 0;
      v = void 0;
      s = '';
      v = void 0;
      i = 7;
      while (i >= 0) {
        v = n >>> i * 4 & 0xf;
        s += v.toString(16);
        i--;
      }
      return s;
    };

    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

    /** Extend String object with method to encode multi-byte string to utf8
     *  - monsur.hossa.in/2012/07/20/utf-8-in-javascript.html
     */
    if (typeof String.prototype.utf8Encode == 'undefined') {
      String.prototype.utf8Encode = function() {
        return unescape(encodeURIComponent(this));
      };
    }

    /** Extend String object with method to decode utf8 string to multi-byte */
    if (typeof String.prototype.utf8Decode == 'undefined') {
      String.prototype.utf8Decode = function() {
        var _error, e;
        e = void 0;
        try {
          return decodeURIComponent(escape(this));
        } catch (_error) {
          _error = _error;
          e = _error;
          return this;
        }
      };
    }
    return Sha256;
  })();

  (function(_) {
    var actions;
    _.go = function(where, callback) {
      if (_.type(where) === _.Type.String) {
        return typeof window !== "undefined" && window !== null ? window.location = where : void 0;
      } else {
        return typeof where.submit === "function" ? where.submit(callback) : void 0;
      }
    };
    actions = [];
    actions.Type = {
      Create: 1,
      Attach: 2,
      Update: 3,
      Detach: 4,
      Delete: 5
    };
    actions["do"] = function(arg) {
      var action, contained, object, parent, position, property, type, uuid, value;
      action = arg.action, object = arg.object, type = arg.type, uuid = arg.uuid, property = arg.property, value = arg.value, parent = arg.parent, contained = arg.contained;
      if (type == null) {
        type = _.type(object);
      }
      switch (action) {
        case actions.Type.Create:
          return actions.push({
            what: action,
            where: {
              u: uuid != null ? uuid : object.uuid,
              n: property,
              c: contained,
              a: parent,
              t: type
            }
          });
        case actions.Type.Attach:
          if (type === _.Type.Array) {
            position = property = object.length;
          }
          return actions.push({
            what: action,
            where: {
              u: _["do"].uuid({
                parent: object,
                property: property,
                create: true
              }),
              n: property,
              d: value,
              a: object._._.uuid,
              p: position
            }
          });
        case actions.Type.Update:
          return actions.push({
            what: action,
            where: {
              u: _["do"].uuid({
                parent: object,
                property: property
              }),
              d: value
            }
          });
        case actions.Type.Detach:
          return actions.push({
            what: action,
            where: {
              u: _["do"].uuid({
                parent: object,
                property: property
              })
            }
          });
        case actions.Type.Delete:
          return actions.push({
            what: action,
            where: {
              u: uuid != null ? uuid : object.uuid
            }
          });
      }
    };
    _["do"] = function(object, uuid) {
      return uuid != null ? uuid : uuid = object.uuid;
    };
    _["do"].flush = function() {
      var actions_;
      if (actions.length === 0) {
        return null;
      }
      actions_ = actions.slice(0);
      actions.length = 0;
      return actions_;
    };
    _["do"].internal = function(object, name, value) {
      var base, base1;
      if (_.isObject(object)) {
        if (object._ == null) {
          object._ = _.type(object) === _.Type.Array ? [] : {};
        }
        if ((base = object._)._ == null) {
          base._ = {};
        }
        if (name != null) {
          if ((base1 = object._._)[name] == null) {
            base1[name] = value;
          }
        }
      }
      return object;
    };
    _["do"].identify = function(object, options) {
      var filter, identified, identify;
      if (options == null) {
        options = {};
      }
      filter = options != null ? options.filter : void 0;
      identified = {};
      identify = function(current) {
        var base, base1, base2, index, item, name, parent, pos, position, ref, ref1, ref2, ref3, ref4, ref5, ref6, type, uuid, value;
        item = current.item, name = current.name, parent = current.parent, position = current.position;
        ref = {
          uuid: _["do"].uuid({
            object: item,
            parent: parent != null ? parent.object : void 0,
            property: name
          }),
          type: _.type(item)
        }, uuid = ref.uuid, type = ref.type;
        if (name === '_') {
          return;
        }
        _["do"].internal(item, 'uuid', uuid != null ? uuid : _.Uuid());
        if ((parent != null ? parent.object : void 0) != null) {
          if ((base = parent.object)._ == null) {
            base._ = _.type(parent.object) === _.Type.Array ? [] : {};
          }
          index = name != null ? name : position;
          if ((base1 = parent.object._)[index] == null) {
            base1[index] = type === _.Type.Array ? [] : {};
          }
          if ((base2 = parent.object._[index]).uuid == null) {
            base2.uuid = uuid != null ? uuid : uuid = _.Uuid();
          }
        }
        switch (type) {
          case _.Type.Object:
          case _.Type.Array:
            switch (type) {
              case _.Type.Object:
                for (name in item) {
                  value = item[name];
                  if (!(name !== '_' && ((filter == null) || (ref1 = value != null ? value.constructor : void 0, indexOf.call(filter, ref1) >= 0)) && identified[(ref2 = value._) != null ? (ref3 = ref2._) != null ? ref3.uuid : void 0 : void 0] !== true)) {
                    continue;
                  }
                  identify({
                    item: value,
                    name: name,
                    parent: {
                      object: item
                    }
                  });
                  if (_.isObject(value)) {
                    identified[value._._.uuid] = true;
                  }
                }
                break;
              case _.Type.Array:
                for (name in item) {
                  value = item[name];
                  if (!(name !== '_' && ((filter == null) || (ref4 = value != null ? value.constructor : void 0, indexOf.call(filter, ref4) >= 0)) && identified[(ref5 = value._) != null ? (ref6 = ref5._) != null ? ref6.uuid : void 0 : void 0] !== true)) {
                    continue;
                  }
                  if ((pos = parseInt(name)).toString() !== name) {
                    pos = null;
                  }
                  identify({
                    item: value,
                    name: (pos != null ? void 0 : name),
                    parent: {
                      object: item
                    },
                    position: pos
                  });
                  if (_.isObject(value)) {
                    identified[value._._.uuid] = true;
                  }
                }
            }
        }
      };
      identify({
        item: object,
        parent: (options.parent != null ? {
          object: options.parent
        } : null),
        name: options.name
      });
      return object;
    };
    _["do"].uuid = function(arg) {
      var base, create, object, parent, property, ref, ref1, ref2, uuid;
      object = arg.object, parent = arg.parent, property = arg.property, create = arg.create;
      if ((object == null) && (parent != null) && (property != null)) {
        object = parent[property];
      }
      if (object == null) {
        return void 0;
      }
      uuid = (ref = object.uuid) != null ? ref : parent != null ? (ref1 = parent._) != null ? (ref2 = ref1[property]) != null ? ref2.uuid : void 0 : void 0 : void 0;
      if ((uuid == null) && create) {
        uuid = _.Uuid();
        if ((parent != null) && (property != null)) {
          parent._[property].uuid = uuid;
        }
        if (object._ == null) {
          object._ = _.type(object) === _.Type.Array ? [] : {};
        }
        if ((base = object._)._ == null) {
          base._ = {
            uuid: uuid
          };
        }
      }
      return uuid;
    };
    _["do"].set = function(object, property, value) {
      var action, index, k, set, v;
      if (!_.isObject(object)) {
        return;
      }
      if (object._ == null) {
        _["do"].identify(object);
      }
      set = function(o, k, v) {
        if (_.isObject(v) && (v._ == null)) {
          _["do"].identify(v);
        }
        return o[k] = v;
      };
      action = actions.Type.Update;
      switch (_.type(property)) {
        case _.Type.Number:
        case _.Type.String:
          if (object[property] == null) {
            action = actions.Type.Attach;
          }
          actions["do"]({
            action: action,
            object: object,
            property: property,
            value: value
          });
          set(object, property, value);
          break;
        case _.Type.Object:
          if (_.type(object) === _.Type.Array) {
            for (k in property) {
              v = property[k];
              if ((index = parseInt(k)) !== Number.NaN) {
                if (object[index] == null) {
                  action = actions.Type.Attach;
                }
                actions["do"]({
                  action: action,
                  object: object,
                  property: index,
                  value: v
                });
                set(object, index, v);
              } else {
                if (object[k] == null) {
                  action = actions.Type.Attach;
                }
                actions["do"]({
                  action: action,
                  object: object,
                  property: k,
                  value: v
                });
                set(object, k, v);
              }
            }
          } else {
            for (k in property) {
              v = property[k];
              if (object[k] == null) {
                action = actions.Type.Attach;
              }
              actions["do"]({
                action: action,
                object: object,
                property: k,
                value: v
              });
              set(object, k, v);
            }
          }
      }
      return object;
    };
    _["do"].pop = function(array) {
      return array.pop();
    };
    _["do"].push = function() {
      var array;
      array = Array.prototype.shift.call(arguments);
      return Array.prototype.push.apply(array, arguments);
    };
    _["do"].reverse = function() {
      var array;
      array = Array.prototype.shift.call(arguments);
      return Array.prototype.reverse.apply(array, arguments);
    };
    _["do"].shift = function() {
      var array;
      array = Array.prototype.shift.call(arguments);
      return Array.prototype.shift.apply(array, arguments);
    };
    _["do"].sort = function() {
      var array;
      array = Array.prototype.shift.call(arguments);
      return Array.prototype.sort.apply(array, arguments);
    };
    _["do"].splice = function() {
      var array;
      array = Array.prototype.shift.call(arguments);
      return Array.prototype.splice.apply(array, arguments);
    };
    return _["do"].unshift = function() {
      var array;
      array = Array.prototype.shift.call(arguments);
      return Array.prototype.unshift.apply(array, arguments);
    };
  })(_);

}).call(this);
